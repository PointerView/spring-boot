SPRING SECURITY

** Anotacion importante, tanto UsernamePasswordAuthenticationFilter como BasicAuthorizationFilter no son interfaces, son clases las cual seran heredadas.


========================= CONFIGURACIONES BASICAS PARA ENCRIPTAR STRINGS Y CONFIGURAR ENDPOINTS =========================

1.- Primero para poder encriptar contraseñas se requiere de un encoder y para ello se definen en clases de configuracion de spring @Configuration y dentro
se crea un bean para poder injectar el encoder, este bean retornara el generico PasswordEncoder y la implementacion sera del algoritmo de encriptacion BCript
con la instancia de new BCryptPasswordEncoder();

2.- Luego para poder encriptar el password se usara el objeto de PasswordEncoder con la implementacio de BCript usando el metodo pw.encode() y se le pasa
como argumento el password retornandolo encriptado como String.

3.- Cuando se incluye las dependencias de spring security se convierten todos los endpoints de los controllers privados y se deben de configurar segundo
las necesidades.

4.-Para configurar esto se hace en la clase @Configuration donde esten las configuraciones de spring, ahi se creara un metodo que retorna un SecurityFilterChain
que es el pipeline de confirmaciones que debera pasar la peticion para saber si esta o no autorizado y objeto el cual sera agregado a los filtros de spring, y
como parametros tendra el HttpSecurity, objeto en el cual se incluiran todas las configuraciones de filtros.

5.- Para indicar un endpoint se hace mediante requestMatchers("") donde se pondra un endpoint, ademas se puede incluir el tipo de verbo con HttpMethod
para limitar ese endpoint aun mas y encadenado a ese metodo se podra usar por ejemplo permitAll() para permitir todos, los demas endpoints que no sean
ese indicado nos referimos a ellos con anyRequest() refiriendose a las demas, se puede exigir autenticacion mediante el metodo encadenado authenticated().

6.- tambien se puede aplicar el CSRF(Cross-Site Request Forgery) que es un mecanismo de seguridad para protegerse de peticiones maliciosas desde el lado de la
vista por ejemplo en formularios, en el caso de trabajar sin ella se puede desabilitar con una lamda.

7.- Al querer confirmar todas las peticiones de los usuarios y no guardar estados/informacion de usuario en el lado del servicor(Stateless) se usa el metodo
encadenado sessionManagement(management -> management.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) para asi confirmar que spring no almacenara
info del usuario, sino que exigira pasar todas las peticiones por el SecurityFilterChain, si no se hiciese el servidor generariua una sesion asignada a 
una JSESSIONID que se pasaria como cookie al cliente y si hace alguna peticion ya tendria guardado y asociado al JSESSIONID informacion como credenciales,
informacion de seguridad informacion de la propia session HTTP.

8.- Cuando se completan todas las configuraciones en el HttpSecurity para pasarlo al SecurityFilterChain se usa el metodo build().

========================= VALIDACIONES DE USUARIOS(AUTHENTICATION) =========================

1.- Para poder validar un usuario en un login es necesario tener una clase @Service que implemente UserDetailsService el cual tiene el contrato de implementar el
metodo loadUserByUsername que tiene como argumento el username, este username sera tomado automaticamente del parmetro de la request que se llame username y 
en el caso de que no este o se llame de otro modo simplemente no lo detectara, para ello desde el front se debera de enviar desde el front con el nombre de
parametro correcto, ademas, el endpoint por defecto de spring para manejar los logins es /login desde la raiz siendo un controller interno no definido por el
programador por lo que las peticiones por defecto seria realizadas a ese mismo endpoint.

2.- Si se quiere enviar desde el front otros nombres de parametros para el username y password como seria nombre y contraseña se podria usar el SecurityFilterChain
que seria el metodo donde se configura la autorizacion de acceso de las request y con el HttpSecurity se podria modificar las caracteristicas del http.formLogin
asignando por ejemplo el loginProcessingUrl("") para indicar otra ruta para el procesamiento del usuario, o usar usernameParameter() y passwordParameter() para
modificar los nombres de los parametros. Un ejemplo seria:
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .formLogin(form -> form
            .loginProcessingUrl("/api/login")   // <-- aquí cambias el endpoint
            .usernameParameter("username")      // opcional, si quieres cambiar nombre de parámetro
            .passwordParameter("password")      // opcional
            .permitAll()                        // permite acceso sin autenticar
        )
        .authorizeHttpRequests(auth -> auth
            .anyRequest().authenticated()
        );

    return http.build();
}

3.- Este controller su idea es de autenticar el usuario y asi crear una sesion(Statefull) con la info del usuario(UserDetails, roles y pasword encriptado) y retornandolo
un JSESSIONID asociada a la sesion que se almacena en las cookies y cada request que haga se pasara ese JSESSIONID con el cual el servidor podra recuperar sus credenciales,
en caso de usar JWT seria Stateless que es justo lo que se busca usandolo, no se guardaria sesion sino que se pasaria el token en cada request y se deberia de validar.

4.- El objetivo de ese endpoint /login es que spring por detras llame al metodo de la clase con la implememtacion de UserDetailsService donde esta la implementacion
de la autenticacion y finalmente retorne el wrapper del usuario autenticado de la clase User de userdetails donde estara el usuario, contraseña, si esta o no activo,
sus roles, etc.

5.- Para pasarle los roles no se pueden pasara de cualquier modo, se deben de pasar dentro de una interfaz wrapper llamada GrantedAuthority la cual usando la 
implementacion SimpleGrantedAuthority se podra incluir en ella el nombre del rol. Como norma general, un usuario tiene mas de un GrantedAuthority por lo que lo normal
es crear una lista de GrantedAuthority y pasarla dentro del constructor de User de userdetails.


========================= IMPLEMENTACION DE JWT MEDIANTE FILTRO USERNAMEPASSWORDAUTHENTICATIONFILTER =========================

1.- Primero para imlpementar jwt es necesario crear un filtro, esto se realiza con una clase que implemente el UsernamePasswordAuthenticationFilter y dentro se
sobreecribiria el metodo attempAuthentication(HttpServletRequest, HttpServletResponse), este filter donde se agrega depues pasa por debajo el request con el
username y password y lo primero seria obtenerlos.

2.- Tambien se necesita una instancia de AuthenticationManager que es el gestor de autenticacion que se encarga de validar las credenciales usando el UserDetailsService
y el PasswordEncoder declarados previamente. La instancia del mismo como norma general se pasa como argumento al constructor de la clase.

3.- Para obtener los datos, lo correcto seria crear un Objeto de tipo User de nuestros models y usar new ObjectMapper para convertir el JSON enviado a tipo objeto,
y para obtener el string del request se puede usar el objeto request.getInputStream() pasandolo como primer parametro siendo el dato a mapear y como segundo valor
la clase User.class de los models, se usa esta clase porque se tiene el atributo username y password y se puede mapear al coincidir con los parametros. Porque hay
que recordar que el back define las reglas(nombres de parametros y funcionalidades) y el front debe seguirlas.

4.- Cuando se tiene los datos de la request ya sea en el objeto User o en variables de username y password deben de usarse para crear una instancia de la clase
UsernamePasswordAuthenticationToken al cual se le pasa en su constructor el usernme y password. Este Token se usara para luego llamar al metodo del authenticationManager
authenticationManager.authenticate(authenticationToken), esto se hace para que spring llame al loadUserByUsername pasandole el username almacenado en el authenticationToken,
luego retorna el UserDetails con los roles y la contraseña encriptada(a partir del username), despues encripta la contraseña pasada en el request en texto plano con el 
PasswordEncoder previamente creado desde el @Bean con la implementacion del algoritmo BCryptPasswordEncoder, en ese momento compara las contraseñas, y si son iguales retorna
el objeto Authentication que contiene el objeto UserDatails, credenciales... El flujo del filtro seria el siguiente :

Petición POST /api/login con JSON
      │
      ▼
attemptAuthentication()
      │
      ├─> Leer JSON del request y extraer username/password
      ├─> Crear UsernamePasswordAuthenticationToken con los datos de username/password
      └─> Llamar authenticationManager.authenticate(UsernamePasswordAuthenticationToken) 
              │
              ▼
     UserDetailsService.loadUserByUsername(username) 
              │
			  ├─>Busca el password del username en la BBDD y la compara con la del request pero antes pasandola por el PasswordEncoder
			  │  para poder hacer la comparacion
              ▼
     Validación de contraseña y roles
              │
              ▼
     Authentication autenticado (devuelto)


========================= CREACION DEL JWT EN CASO DE AUTHENTICATION SUCCESSFULL =========================

5.- Cuando ya se tiene el Authetication listo, es necesario crear los metodos para el caso de que sea successful o unsuccessful, para el successful seria necesario crear
el metodo successfulAuthentication sobreescrito de la herencia de la implementacion de la clase UsernamePasswordAuthenticationFilter, en este caso al trabajar con JWT
se debera de crear el mismo y enviarlo en el response, esto se realiza primero obteniendo del parametro Authentication el UserDetails, eso se hace mediante el metodo
authResult.getPrincipal() el cual retorna un Object el cual se puede castear a la implementacion de UserDetails que seria la clase User mediante casteo manual.

6.- Despues de obtener el objeto User con el contenido del UserDetails solo quedaria tener una secret_key con la que firmar el JWT, para ello se en estos momentos
Jwts.SIG.HS256.key().build() aunque esto suele cambiar a veces pero con mirar en la documentacion de JWT como crear una firma/clave secreta ya estara indicado, estas
firmas no se pasan entre request, siempre se quedan en el lado del servidor para mayor seguridad.

7.- Teniendo ya el username y la secret_key ya se podria construir el JWT, esto se hace mediante eun metodo estatico de la clase Jwts del siguiente modo:
String token = Jwts.builder()
    .subject(username)     → metes el nombre de usuario como el “dueño” del token.
    .signWith(SECRET_KEY)  → firmas el token con tu clave secreta para que no pueda ser manipulado.
    .compact();            → genera el string final del JWT.
	
8.- Este seria el modo mas simple de crear un token pero solo usa un claim(payload/info) estandar que es subject, los otros dos metodos forman parte de las necesidades de
la creacion del token, pero se pueden agregar mas claims estandars , estos son los mas tipicos de usar:
	→ issuer (quién emitió el token)
	→ subject (el usuario principal)
	→ audience (quién puede usarlo)
	→ expiration (fecha de caducidad)
	→ issued at (fecha de emisión)
	
9.- Son claims estandar porque Jwts creo metodos directos para agregarlos pero tambien se pueden crear claims personalizados, estos se crean mediante otro metodo estatico de Jwts
que seria Jwts.claims() el cual con el .add() se puede hacer mediante key value pair a lo Map nuevos claims, tras agregar todos se usar build() para crear un solo objeto de tipo
Claims el cual en el builder() del Jwts se puede usar el metodo claims() y pasar el objeto de tipo Claims por argumento agregandose al token de JWT.

10.- En los claims lo normal es guardar los roles, para elos se pueden obtener tanto del objeto User implementacion de UserDatails, como de el parametro Authentication con el metodo
getAuthorities, el ultimo metodo es mas recomendado porque User solo retorna GrantedAuthority pero el getAuthorities() retorna un generico que herede de GrantedAuthority
<? GrantedAuthority> lo cual si en algun momento se cambia de implementacion este modo seria mas generico. Pero sea como sea retorna un Collection<> de un tipo generico asique el retorno
se tendra que guardar en una variable de ese tipo y posteriormente guardarlo en el objeto claims el cual lo normal seria guardarlo pasado a String con el ObjectMapper porque tras retornarlo
en el response dentro del JSON, si no se pasa a string no se vera su contenido.

11.- Tras hacer el compat() del token retorna el token en un String, tras tenerlo hay que pasarlo al response, esto se hace primero indicando el el header el tipo de respuesta que
mediante la key "Authorization" y con el valor que seria el token, pero eso si, siempre debe de ir precedido de la palabra clave estandar Bearer, esto solo indica que el header es
poseedor de un token y ademas al haber otros tipos de esquemas de token aparte de JWT ponerlo ayuda a diferenciarlo, ademas los filtros toman los headers y necesitan Bearer para saber
si tiene token y de ese modo obtenerlo. Tras configurar el header queda configurar el contentType, este sera "application/json" ya que a parte de pasar el token en el header, lo normal
es tambien pasarlo en el cuerpo de la respuesta por eso es que se pone el tipo de respuesta ya que hay que recordar que aqui no se tiene un RestController y hay que configurarlo manualmente.
Muy importante saber que spring no hace pasar todas las request por todos los filtros, lo que hace es dependiendo del header de la peticion pasara por unos y no por otros, por eso es
importante incluir el header de authorization con el Bearer token

12.- Tras tener todo configurado quedaria crear un Map con minimo el token y el username, y tambien se podria poner algun mensaje de inicio de sesion o algo asi.

13.- Tras tener el Map listo se debera de primero pasar este objeto al response, como solo puede almacenar datos mediante su writer y solo pueden ser strings, sera necesario pasar
el objeto en modo string, para ello se puede usar el new ObjectMapper().writeValueAsString(objeectMap) el cual convierte el objeto a string.

14.- Finalmente se establece el status de la respuesta, en este caso como esta autorizado lo normal es poner un OK(200)


========================= RESPUESTA EN CASO DE AUTHENTICATION UNSUCCESSFULL =========================

Primero de todo es importante saber que estos metodos de successfulAuthentication y unsuccessfulAuthentication no se deben de llamar manualmente en ningun lado, spring dependiendo del
resultado de la autorizacion llamara por el mismo a un metodo o a otro. 

15.- En caso de no ser autorizado a acceder al path pues se accedera a este metodo y aunque no se le puede pasar el token se debera de dar algun tipo de respuesta para informar de lo
sucedido para que el front pueda responder tambien, para ello lo normal es crear un Map con un mensaje de error, ademas a diferencia del successfulAuthentication que tiene como parametro
el objeto Authentication con la info del UserDetails, en este metodo esta el parametro de tipo AuthenticationException el cual tiene info interna del error, info la cual seria tambien
importante de agregar al map para pasarlo a la respuesta.

16.- Tras completar el Map con la info se debera como siempre configurar el contentType que tambien seria appplication/json por pasar un Map, y tambien configurar el status a Unauthorized(401).

17.- Finalmente se debera de agregar el map a la respuesta pasandolo antes a string con el ObjectMapper().writeValueAsString(map);

========================= OBTENCION DEL AUTHENTICATION MANAGER Y AGREGACION DEL FILTRO =========================

1.- Primero para obtenerlo se requiere de un objeto de la clase AuthenticationConfiguration el cual se obtiene mediante injeccion al ser un Bean de spring boot.

2.- Para poder usar el AuthenticationManager en multiples lugares sin necesidad de instanciarlo manualmente lo mejor seria crear un Bean producer en un metodo en el cual se incluira en su
definicion el metodo de la clase AuthenticationConfiguration authConf.getAuthenticationManager() el cual retorna el objeto de AuthenticationManager, y de este modo se podra obtener con Autowired.

3.- Tras tener el @Bean del AuthenticationManager ya se podra agregar el filtro de autenticacion y autorizacion al SecurityFilterChain mediante el parametro del metodo filterChain
HttpSecurity. Aqui se usaria el metodo addFilter() en el cual se pasara como argumento una instancia del objeto de la clase del filtro e importante, pasarle como argumento del constructor 
el AuthenticationManager el cual hay que recordar que es el encargado de realizar la autenticacion mediante el paso del username y password al loadUserByUsername y confirmando si esta o no
autorizado retornando el la implementacion User de la interfaz UserDetails el cual se almacena en el Authentication.


========================= CONFIGURACION DEL VALIDADOR DEL JWT =========================

1.- En el anterior filtro, solo pasaban las request que entraran por el endpoint /login que es el endpoint por defecto de Spring para formLogins, los demas no pasan y esto lo sabe spring por
motivo de la herencia de UsernamePasswordAuthenticationFilter, ("Esta peticion se envio a /login?  ---> "Paso la request al filtro con la interfaz UsernamePasswordAuthenticationFilter").

2.- En el caso de crear un filtro para poder validar el token, como la idea es que sea una validacion sin estado(Stateless) lo que se busca es validar todas las request por lo que se usaria una clase
con la herencia de BasicAuthorizationFilter el spring pasa todas las request y por ello es que sera necesaio filtrar cuales deberan de pasar por el metodo de filtrado implementado en el contrato de
la interfaz llamado doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain) el cual como se ve es un filter normal de JakartaEE pero personalizado para esto, y en el usar el if para confirmar
si esa request contiene en los headers un token Bearer el cual validar, si no lo tiene tan solo se pasa al siguiente paso con doFilter(req, resp)

3.- Importante tener definido un constructor que reciba el AuthenticationManager para poder realizar la validacion del token.

4.- Para poder validar el token es necesario eliminar la palabra Bearer para solo quedarnos con el, lo mas comun es usar el replace("Bearer", "") para eliminarlo.

5.- Para obtener la info del token se necesita un parser que convierta el token a la info que lo contiene, para ello se usar Jwts.parser() el cual retorna el parser.

6.- El parser no sabe con que clave secreta se creo el token y con la cual tambien se usa para descifrarlo, por ello se le tiene que dar con el metodo del parser .verifyWith(SECRET_KEY)
y luego usar el metodo .build() para aplicar la configuracion al parser.

7.- Despues de tener listo el parser se debera de pasar el token a descifrar, para ello se usara el metodo del parser llamado .parseSignedClaims(TOKEN) y se le pasara el token como argumento.

8.- Finalmente para obtener toda su info se usara el metodo .getPayload() que payload significa la informacion para que algo funcione, en este caso el token.

9.- Todo este proceso se debera de colocar en un try-catch ya que el token podria haber sido manipulado o dejar de ser valido ya sea por expiracion o por otro motivo y dara una JwtException la cual se
deberia de manejar y retornar en la respuesta un mensaje que avise sobre esto.

10.-Tras usar este ultimo metodo getPayload(), retornara toda la info del token en forma de un objeto de clase Claims. Este objeto tiene los metodos para obtener los claims estandar y el metodo get()
el cual pasando una key retornara el value igual que un Map.

11.- Posteriormente se necesitara un Collection<? extends GrantedAuthority> pero nuestros authorities son retornados como JSON en un Object por lo que se necesitara convertirlo, esto se hace mediante
un new ObjectMapper(). Jackson siempre analiza primero el JSON y los ordena en nodos de Kay/Value y luego busca crear una instancia con el constructor por defecto obteniendo un objeto vacio para 
posteriormente usar los setters y colocar en cada atributo los valores ordenados en los JsonNodes. En el caso de SimpleGrantedAuthority no tiene ni constructor por defecto ni setters publicos por lo que
se debera de usar un mixin que significa("Cuando vayas a instanciar un objeto de la clase X, usa el constructor de la clasee Y), se puede hacer de dos modos, dando como segundo paramentro una clase 
abstracta personalizada para que jackson pueda instanciar el objeto, esto se hace con un constructor en clase abstracta anotado con @JsonCreator y luego en el constructor como parametro se usa 
@JsonProperty("name") siendo el nombre la Key del JsonNode que queremos mapear a la variable incluida justo despues de la anotacion.
Esta clase sera pasada como segundo argumento en el metodo del ObjectMapper().addMixIn(ClaseAInstanciar, ClaseAbstractaConElConstructor).

12.- La segunda forma es usar la clase creada por defecto de SpringBoot que es SimpleGrantedAuthorityMixin.class la cual hace lo mismo que la que se crea personalizada.

13.- Despues de tener el mixin se debe de pasar lo que se quiere mapear y a lo que se quiere mapear, esto se hace con el .readValue() de siempre y se le el objeto pero readValue solo acepta strings o 
arrays de bytes por lo que se puede hacer de dos modos, readValue(authoritiesClaims.toString().getBytes(), SimpleGrantedAuthority[].class) asi se pasaria el flujo de bytes, pero para segun que tipo de 
datos podria dar error, por ejemplo un Map, su key no es "primeraKey" sino primeraKey sin llaves lo cual json no acepta, por eso la segunda opcion mas segura seria usar el metodo del ObjectMapper()
objMapper.writeValueAsString(authoritiesClaims) lo cual pasa un json valido a string y luego esto ya pasarlo al readValue dejando algo talque asi:

ObjectMapper mapper = new ObjectMapper();
String json = mapper.writeValueAsString(authoritiesClaims);
SimpleGrantedAuthority[] authoritiesArray = mapper
    .addMixIn(SimpleGrantedAuthority.class, SimpleGrantedAuthorityJsonCreator.class)
    .readValue(json, SimpleGrantedAuthority[].class);

** Probado que si no es un Map con pasarlo a string ya funciona, no es necesario pasar los bytes.

14.- Tras tener esto se debe de guardar la info del token en el contenxto de seguridad y que se mantenga durante toda la request para que cuando llegue al verdadero endpoint de destino, esta info se mantenga
en el contexto y se pueda hacer comprobaciones de roles, para hacer esto se añadira en el SecurityContextHolder con su metodo static getContext() para obtener el contexto, y despues agregar la autenticacion, esto
se hace mediante el metodo setAuthentication() al cual se le pasa la info obtenida del token, esta info no se puede pasar de cualquier modo si no que al ser un traspaso de info del usuario entre metodos en medio
de una request, se hara uso del UsernamePasswordAuthenticationToken al cual se le pasara el username, el Object generico donde estaba el json con los authorities el cual se pasa por conveniencia aunque podria ser null
y las authorities que es el collection con las implementaciones de SimpleGrantedAuthority de GrantedAuthority.
Entonces el ultimo paso de crear el UsernamePasswordAuthenticationToken y agregarlo al contexto de seguridad del request quedaria asi:

UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username, authoritiesClaims, authorities);
SecurityContextHolder.getContext().setAuthentication(authenticationToken);
chain.doFilter(request, response);





========================= USOS DEL AUTHENTICATION MANAGER =========================

Es el corazon de spring, cualquier tipo de autenticación (username/password, JWT, OAuth) pasa por aquí si quieres usar el mecanismo estándar de Spring. Autenticar un objeto Authentication el cual contiene 
el campo principal con el username o UserDetails, las credenciales , authorities que es una colección de GrantedAuthority y el authenticated que es un boolean para saber si ya ha sido autenticado

El objeto Authentication sirve como “tarjeta de identidad” del usuario dentro de Spring Security:

--> Transporta username y credenciales al AuthenticationManager para validar login.
--> Transporta roles y permisos a Spring Security para decidir si puede acceder a un recurso (@PreAuthorize, filtros, etc.).
--> Se almacena en el SecurityContext durante la request

========================= USOS DEL UsernamePasswordAuthenticationToken =========================

Es una clase wrapper que implementa Authentication que representa la autenticacion del usuario, esta clase wrapper almacena informacion completa sobre el usuario como la info principal que almacena el
UserDetails, las credenciales o las authorities. Esta clase se usa como media de transporde de la info de autenticacion dentro de spring ya que como se ve se usa para pasar la info entre diferentes metodos
que gestionan la autenticacion y autorizacion.

========================= USOS DEL GrantedAuthority y SimpleGrantedAuthority =========================

La primera es una Interfaz y la segunda es una clase que implementa la interzar, lo normal es usar instancias de la implementacion y almacenar los roles ya que la clase no es mas que una clase wrapper
que almacena los roles y la cual spring utiliza para manejar las validaciones.