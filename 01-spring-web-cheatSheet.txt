


========================= CREACION DE CONTROLADORES =========================

1.- Se crean controladores simples que solo retornan vistas con @Controller en la clase, estas retornan vistas y si se quiere pasar algun dato se usara el parametro injectado de tipo
Model o Map y no se retorna sino que automaticamente se pasa a la vista como atributos del request.

2.- Para crear diferentes endpoints en el Controller se usa @GetMapping() para crear un verbo get y se le puede dar un path personalizado o dejarlo por defecto que seria la raiz o 
el path del controlador.

3.- Para crear un path general del controlador se usa RequestMapping() y ese path sera compartido por todos los endpoints junto con la extension opciona que le de cada uno de los metodos.

4.- Si se quiere retornar valores complejo y no vistas se usara un controlador que sea @ResponseBody lo cual aplicara a todos los metodos, o aplicar esta misma anotacion a los metodos que
queramos que retorne un objeto JSON en el body. Tambien se puede en vez de usar @Controller y @ResponseBody, se puede usar el stereotype @RestController que contienen ambas etiquetas mencionadas.

5.- Si queremos recibir parametros en un get, como estandar se pasa como queryParam (?key=value&key=value) y esto se recibe en los paramentros del metodo con @RequestParam, pero tambien esta otro
modo de enviar el cual es mejor para temas de indexacion y SEO que es con PathVariable que se incluir el paramentro como parte del mismo path (path/{value}) y esto se obtiene poniendo junto a un
parametro en @PathVariable, de los dos modos el key debera de ser igual que el nombre del atributo y si esto no es asi se debera de agregar el name en la anotacion.

6.- En peticiones post donde normalmente se pasan objetos complejos se requerira de la anotacion @RequestBody, parecida a ResponseBody que es para la respuesta, pues en este caso para la peticiones
seria @RequestBody, de este modo spring ajustara el json recibido a una instancia del objeto.

7.- Si se quiere inyectar una propertie se usa @Value("${}") con una expresion y el nombre de la property, eso si, este file de properties debe de haber sido agregado a los propertySource de las configs

8.- Si queremos instanciar un objeto de una clase, esta si es anotada con @Componente se agregaria al contexto de beans de spring y asi se podria inyectar su valor declarativamente mediante la 
anotacion @Autowired, muy parecido al @Inject de API CDI.

8.1.- Si se quiere usar @Autowired pero hay mas de una posible implementacion se pueden solucionas de tres principales modos:
	--> Usar la anotacion @Primary en el componente para dejar los demas como secundarios e inyectar el principales
	--> Usar Qualifier indicando el nombre de la clase(nombre asignado por defecto al componente) o el nombre personalizado indicado en Component('name')
	--> Usar en el nombre del atributo el nombre del componente ya sea el nombre por defecto o el asignado personalizado en Component.

9.- Para la creacion de componentes de services y de repositories estan los Stereotypes de @Service y @Repository que por debajo hacen a las clases componentes.

10.- En spring los componentes tambien tienen contextos y ambitos los cuales pueden ser 4 que serian los siguientes:
 * Singleton: Un solo objeto en una sola aplicacion de spring de las muchas que pueden haber en un servidor
 * ApplicationScope: Un objeto para todas las aplicaciones de spring, alcance mas aplio que el Singleton
 * SessionScope: Un objeto para toda la aplicacion pero asignada a un unico cliente.
 * RequestScope: Un objeto para un cliente para una sola request
 
11.- Al igual que todo objeto que tiene un ambito tiene un ciclo de vida y aqui es lo mismo, se tiene el @PostConstruct el cual el metodo se ejecutara justo despues de completar el objeto contando con 
la ejecucion del constructor y la inicializacion de los atributos, y luego esta @PreDestroy lo cual se ejecuta justo antes de destruir el objeto

12.- Cuando se quiere inject de un objeto de una clase propia con anotar con Component y usar @Inject ya vale pero si se quiere injectar un tipo de dato mas complejo que requiere de algun tipo de preparacion
se pueden crear BeansFactories, estos son metodos anotados con @Bean que retorna un valor y ese es injectado en una variable, esto se hace binding mediante el tipo de dato de retorno, si se hace @Bean que retorna
un List<Pelotas> y luego se hace un @Inject a un List<Pelotas> se injecta el retorno de ese metodo, si se tienen multiples beansFactories que retornan un mismo tipo se puede usar Primary o darle un nombre al bean.


** Recordar que la anotacion @Bean no solo injecta una instancia, tambien s

========================= EXCEPCIONES =========================

Para el manejo de excepciones se pueden crear un manejador global de excepciones en una clase mediante @RestControllerAdvice que contiene @ResponseBody y @ControllerAdvice para el manejo de excepciones, depues
se crean metodos que con @ExpcetionHandler(claseExcepcion) se puede indicar que si salta esta expcepcion se ejecute el metodo, dentro se retornara un ResponseEntity con el cual se puede manejar tanto el body como 
los headers y el status, es un wrapper total de la respuesta HTTP, ahi se dara un status de error y un body de un objeto o map con info sobre el error si es necesario. Tambien se puede dar un status estatico que no
se defina en el ResponseEntity y es mediante la anotacion en el metodo de @ResponseStatus(HttpStatus.XXX) y siempre que entre a este metodo por la excepcion indicada retornara ese mismo estado siempre. Importante
saber que un metodo puede tener en el ExpcetionHandler una o mas clases de expeciones. Tambien importante saber que estos metodos tiene el paramentro de la excepcion donde se podra encontrar informacion de la misma
como el mensaje enviada a la hora de instanciar y lanzar la expcepcion misma.

========================= INTERCEPTORS =========================

Para crear interceptores primero se debe de crear una clase componente que implemente la interfaz HandlerInterceptor, esta tiene en el contrato dos metodos obligatorios que son preHandle y postHandle, ambos
tienen como parametros el HttpServletRequest, HttpServletResponse y el Object que es el metodo el cual se esta interceptando, el postHandle es void pero en preHandle es boolean siendos asi porque si retorna true
ejecutara el metodo interceptado pero si retorna false finalizara la ejecucion. Para pasar datos no se puede usar el return sino el HttpServletResponse.
Cuando se tiene creado el interceptor hay que hacer binding al metodo/metodos que se quieran interceptar y eso se hace desde una clase de configuracion que implemente la interfaz de WebMvcConfigure que tiene en
contrato el metodo addInterceptors con el parametro de InterceptorResistry con el cual se podra usar el metodo registry.addInterceptor(objetoInterceptor).addPathPatterns() y ahi indicar los endpoins a interceptar,
tambien se puede usar excludePatterns() y excluir los puestos como argumentos.
La diferencia de los Interceptores de Spring y de Jakarta es que en spring interceptan la peticion HTTP como los filters de Jakarta mientras que los interceptors de Jakarta interceptan el metodo

========================= AOP(Aspect Oriented Programing) =========================

La AOP es parecido a los interceptores de JakartaEE, interceptan la ejecucion de un metodo y todo ello lo hacen unos metodos dentro de una clase de aspectos, para crear todo esto seria :

1.- Crear una clase que sea anotada con @Aspect y @Component.

2.- Dentro se podra implementar metodos con los diferentes momentos donde se puede interceptar los metodos que son los siguientes:
| Anotación         | Se ejecuta…                                     |
| ----------------- | ----------------------------------------------- |
| `@Before`         | Antes del método                                |
| `@After`          | Siempre después (éxito o error)                 |
| `@AfterReturning` | Solo si el método devuelve sin error            |
| `@AfterThrowing`  | Solo si el método lanza excepción               |
| `@Around`         | Antes y después (puede reemplazar la ejecución) |

Estos metodos siempre se ejecutan en un mismo orden que seria:

@Around (antes)
   └─> @Before
        └─> Método objetivo
              ├─> @AfterReturning (si OK)
              └─> @AfterThrowing (si error)
        └─> @After (siempre)
@Around (después)

Si un metodo esta interceptado por mas de un metodo se usa la anotacion Order(num) para indicar cual tiene la prioridad pero no significa que primero se ejecute todo de una clase y luego otra sino que
se da prioridad a un metodo con una anotacion y luego se ejecuta el otro metodo con la misma anotacion de la otra clase para que despues se vuelva a la clase con mas prioridad y se pase al segundo metodo
que seria el before despues del around.

**Los metodos de AOP interceptan el metodo como los interceptores de JakartaEE


========================= TRANSACCIONES =========================

Para el manejo de transacciones tambien se manejan de manera automaticamente dependiendo si es para operaciones de lectura o de escritura,
en ambas se usa la anotacion de @Transaction pero para lectura se aplica en sus argumentos readOnly=true


========================= SPRING BOOT JPA =========================

1.- JPA aplicado a SB es muy similar a JPA nativo, anotaciones de @Entity, @Table para las clases, @Id, @GeneratedValues(), @Column(), @JoinColumn(),
@JoinTable(), todas las anotaciones de asociaciones, todo esto es igual, pero la parte donde tiene extras seria en las imlementaciones de los
repositorios, en JPA nativo se debes de crear las consultas pendiante JPQL o usando los metodos de find, merge, persist o delete pero en JPA con sprgin
permite varias cosas.
	--> Crear consultas nativas de sql mediante @Query(value="consulta", nativaQuery=true)
	--> Crear consultas de JPQL @Query("consulta")
	--> Crear consultas con queryMethods, usando palabras clave siempre empezando por findBy y luego keyWords para crear la consulta,
		esto solo esta pensado para consultas SELECT
Cuando se hacen queries que son UPDATE o DELETE se usa la anotacion @Modifying, pero no para SELECT o INSERT.

2.- Importante saber que para la configuracion de Spring Data JPA no es necesario la configuracion del presistence.xml, con tan solo configurar
el application.porperties es suficiente.

3.- No trabaja directamente con el EntityManager si no que se usan los metodos de la implementacion de CrudRepository o JpaRepository los cuales ya
incluyen un crud listo y el manejo de los recursos es automatico.

4.- No es necesario implementar interfaces genericas para los diferentes repositorios porque con las que incluye JPA ya es suficiente.

5.- Transacciones manejadas automaticamente con la anotacion @Transactional la cual se puede aplicar a nivel de metodo, clase o incluso de servicio
y automaticamente se propagaria a todos los metodos.


========================= SPRING VALIDATOR =========================

En SpringBoot Validator se tiene el modo basico de validacion que es mediante las anotaciones propias de la libreria como @NotNull, @NotEmpty... y luego
aplicar la anotacion @Valid antes del objeto a validar y posteriormente la interfaz de BindingResult que contendria toda la informacion de la validacion
pero en muchos casos esto es insuficiente y se requiere de crear validadores personalizados y esto se haria del siguiente modo:

1.- Se crea una interfaz de anotacion la cual se anotara con @Constraint(validatedBy = XXX.class), de este modo crearemos una anotacion binding que se
aplicara a los elementos que queramos validar, tipos de datos los cuales se debe de indicar en el @Target y ademas indicar que el @Retention es Runtime,
ademas dentro de la anotacion se debera de incluir minimo un metodo con esta firma String message() default "mensaje que devuelve si no pasa la validacion"

2.- Cuando se tenga la anotacion se debera de vincular la misma con la clase que tendra el metodo validador, esto se hace mediante la interfaz a implementar
ConstraintValidator<AnotacionBinding, TipoDeDatoAValidar> la cual en el contrato implementara el metodo isValid donde se implementara la validacion y retornara
true si todo salio bien o false si la validacion no salio correctamente. Ademas el metodo handler tiene dos parametros, el objeto que se esta validando y
el contexto del validador con el cual se puede personalizar el error que pasaria el validator si es que retorna false

3.- La anotacion se aplicara del mismo modo que se aplican las demas, sobre lo que se quiera validar


